---
title: "Untitled"
output: html_document
date: "2023-06-19"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

```

```{r}
#load in the TPM data
tpm = read.table("GSM1536837_06_01_15_TCGA_24.tumor_Rsubread_TPM_filtered.txt", header=TRUE, sep="\t", as.is=c(1,2))
head(tpm)
```


```{r}
tpm[is.na(tpm)] = 0
```

```{r}
head(tpm)
```


Check the sample sizes of tpm. Notice that the sums of samples are all equal to 10^6.
```{r}
colSums(tpm[-1])
```

```{r}
row_names = tpm$Gene
tpm = tpm[-1]
rownames(tpm) = row_names
head(tpm)
```


Loading of clinical data
```{r}
# Loading
library("readxl")

# xlsx files
clinical_data <- read_excel("Dataset 1.xlsx")
head(clinical_data)
```


```{r}
clinical_data.BRCA = clinical_data[clinical_data$`CANCER TYPE` == "BRCA", ]
#clinical_data.BRCA = clinical_data.BRCA[!is.na(clinical_data.BRCA$`MOLECULAR PROFILING BEFORE OR AFTER RADIATION TREATMENT`),]
head(clinical_data.BRCA)
```

```{r}
sample_names = names(tpm)[1:length(names(tpm))]
sample_names.formated = chartr(".", "-", substr(sample_names, 1,16))
```


```{r}
sample_names.BRCA = sample_names[sample_names.formated %in% clinical_data.BRCA$SAMPLE]
tpm.BRCA = tpm[ , names(tpm) %in% sample_names.BRCA]
head(tpm.BRCA)
```

## Exploratory analysis of the read count table

A typical quality control, in this case interrogating the RNA-seq experiment design, is to measure the similarity of the samples with each other in terms of the quantified expression level profiles across a set of genes. One important observation to make is to see whether the most similar samples to any given sample are the biological replicates of that sample. This can be computed using unsupervised clustering techniques such as hierarchical clustering and visualized as a heatmap with dendrograms. Another most commonly applied technique is a dimensionality reduction technique called Principal Component Analysis (PCA) and visualized as a two-dimensional (or in some cases three-dimensional) scatter plot. 

### Clustering

We can combine clustering and visualization of the clustering results by using heatmap functions that are available in a variety of R libraries.

```{r}
#compute the variance of each gene across samples
V <- apply(tpm.BRCA, 1, var)
#sort the results by variance in decreasing order 
#and select the top 100 genes 
selectedGenes <- names(V[order(V, decreasing = T)][1:100])
```


Now we can quickly produce a heatmap where samples and genes are clustered

```{r fig2, fig.height = 7, fig.width = 20, fig.align = "center"}
library(pheatmap)
pheatmap(tpm.BRCA[selectedGenes,], scale = 'row', show_rownames = FALSE, cellheight=2, cellwidth = 8, fontsize_col = 6, cluster_cols=T)
```

We can also overlay some annotation tracks to observe the clusters. Here it is important to observe whether the replicates of the same sample cluster most closely with each other, or not. Overlaying the heatmap with such annotation and displaying sample groups with distinct colors helps quickly see if there are samples that don’t cluster as expected

```{r}

#metadata = data.frame(clinical_data.BRCA[c("RADIATION RESPONSE", "RADIATION CLASS")])#, 
                                       # "GENDER", "HISTOLOGY", "RACE", 
                                       # "MOLECULAR PROFILING BEFORE OR AFTER RADIATION TREATMENT")])

metadata = data.frame(clinical_data.BRCA[c("HISTOLOGY", "RADIATION CLASS")])
rownames(metadata) = sample_names.BRCA
head(metadata)

```


```{r fig2, fig.height = 7, fig.width = 25, fig.align = "center"}
pheatmap(tpm.BRCA[selectedGenes,], scale = 'row', 
         show_rownames = FALSE, 
         annotation_col = metadata, fontsize_col = 5)
```

### PCA

```{r}
library(stats)
library(ggplot2)
library(ggfortify)
#transpose the matrix 
M <- t(tpm.BRCA[selectedGenes,])
# transform the counts to log2 scale 
M <- log2(M + 1)
#compute PCA 
pcaResults <- prcomp(M)

#plot PCA results making use of ggplot2's autoplot function
#ggfortify is needed to let ggplot2 know about PCA data structure. 
autoplot(pcaResults, data = metadata, colour = 'HISTOLOGY', shape = 'RADIATION.CLASS')
```
We can use the summary function to summarize the PCA results to observe the contribution of the principal components in the explained variation.

```{r}
summary(pcaResults)
```
### Correlation plots

Another complementary approach to see the reproducibility of the experiments is to compute the correlation scores between each pair of samples and draw a correlation plot.

Let’s first compute pairwise correlation scores between every pair of samples.

```{r}
library(stats)
# Correlation between samples
correlationMatrix <- cor(tpm.BRCA)
```

We can also draw more visually appealing correlation plots using the corrplot package. Using the addrect argument, we can split clusters into groups and surround them with rectangles. By setting the addCoef.col argument to ‘white’, we can display the correlation coefficients as numbers in white color.

```{r fig2, fig.height = 25, fig.width = 25, fig.align = "center"}
library(corrplot)
corrplot(correlationMatrix, order = 'hclust', 
         addrect = 2, addCoef.col = 'white', 
         number.cex = 0.5, tl.cex = 0.5, cl.cex = 0.5) 
```

Here pairwise correlation levels are visualized as colored circles. Blue indicates positive correlation, while Red indicates negative correlation.

We could also plot this correlation matrix as a heatmap. As all the samples have a high pairwise correlation score, using a heatmap instead of a corrplot helps to see the differences between samples more easily. The annotation_col argument helps to display sample annotations and the cutree_cols argument is set to 2 to split the clusters into two groups based on the hierarchical clustering results.

```{r fig2, fig.height = 25, fig.width = 25, fig.align = "center"}
library(pheatmap)
# split the clusters into two based on the clustering similarity 
pheatmap(correlationMatrix,  
         annotation_col = metadata, 
         cutree_cols = 2)
```


## Differential expression analysis

Differential expression analysis allows us to test tens of thousands of hypotheses (one test for each gene) against the null hypothesis that the activity of the gene stays the same in two different conditions. There are multiple limiting factors that influence the power of detecting genes that have real changes between two biological conditions. Among these are the limited number of biological replicates, non-normality of the distribution of the read counts, and higher uncertainty of measurements for lowly expressed genes than highly expressed genes.

There, we calculated gene-wise variability and shrunk each gene-wise variability towards the median variability of all genes. In the case of RNA-seq the dispersion coefficient $\alpha$ is shrunk towards the value of dispersion from other genes with similar read counts.

```{r}
#load in the uncorrected data as raw counts
countData = read.table("GSM1536837_06_01_15_TCGA_24.tumor_Rsubread_FeatureCounts_filtered.txt", header=TRUE, sep="\t", as.is=c(1,2))
head(countData)
```
```{r}
row_names = countData$Gene
countData = countData[-1]
rownames(countData) = row_names
head(countData)
```



```{r}
colData = data.frame(clinical_data[c("RADIATION CLASS")])

rownames(colData) = sample_names
head(colData)
```

```{r}
#define the design formula
designFormula <- "~ RADIATION.CLASS"
```

Run DESeq2
```{r}
library(DESeq2)
library(stats)
#create a DESeq dataset object from the count matrix and the colData 
dds <- DESeqDataSetFromMatrix(countData = countData, 
                              colData = colData, 
                              design = as.formula(designFormula))
#print dds object to see the contents
print(dds)
```
The DESeqDataSet object contains all the information about the experimental setup, the read counts, and the design formulas. Certain functions can be used to access this information separately: rownames(dds) shows which features are used in the study (e.g. genes), colnames(dds) displays the studied samples, counts(dds) displays the count table, and colData(dds) displays the experimental setup.

Remove genes that have almost no information in any of the given samples.

```{r}
#For each gene, we count the total number of reads for that gene in all samples 
#and remove those that don't have at least 1 read. 
dds <- dds[ rowSums(DESeq2::counts(dds)) > 1, ]
```

Now, we can use the DESeq() function of DESeq2, which is a wrapper function that implements estimation of size factors to normalize the counts, estimation of dispersion values, and computing a GLM model based on the experimental design formula. This function returns a DESeqDataSet object, which is an updated version of the dds variable that we pass to the function as input.

```{r}
dds <- DESeq(dds)
```

Now, we can compare and contrast the samples based on different variables of interest. In this case, we currently have only one variable, which is the group variable that determines if a sample belongs to the Radiation sensitive group or the Radiation resistant group.

```{r}
#compute the contrast for the 'group' variable where 'Sensitive' 
#samples are used as the control group. 
DEresults = results(dds, contrast = c("RADIATION.CLASS", 'Resistant', 'Sensitive'))
#sort results by increasing p-value
DEresults <- DEresults[order(DEresults$pvalue),]
```

Thus we have obtained a table containing the differential expression status of case samples compared to the control samples.

```{r}
#shows a summary of the results
print(DEresults)
```
The first three lines in this output show the contrast and the statistical test that were used to compute these results, along with the dimensions of the resulting table (number of columns and rows). Below these lines is the actual table with 6 columns: baseMean represents the average normalized expression of the gene across all considered samples. log2FoldChange represents the base-2 logarithm of the fold change of the normalized expression of the gene in the given contrast. lfcSE represents the standard error of log2 fold change estimate, and stat is the statistic calculated in the contrast which is translated into a pvalue and adjusted for multiple testing in the padj column. 

### Diagnostic plots

At this point, before proceeding to do any downstream analysis and jumping to conclusions about the biological insights that are reachable with the experimental data at hand, it is important to do some more diagnostic tests to improve our confidence about the quality of the data and the experimental setup.

#### MA plot

An MA plot is useful to observe if the data normalization worked well. The MA plot is a scatter plot where the x-axis denotes the average of normalized counts across samples and the y-axis denotes the log fold change in the given contrast. Most points are expected to be on the horizontal 0 line (most genes are not expected to be differentially expressed).

```{r}
library(DESeq2)
DESeq2::plotMA(object = dds, ylim = c(-7, 7))
```
DESeq2 includes a function to perform downstream processing of the estimated log fold change values called lfcShrink which is advised to always run afterwards. The reason for executing this function is described in the vignette with:

“It is more useful visualize the MA-plot for the shrunken log2 fold changes, which remove the noise associated with log2 fold changes from low count genes without requiring arbitrary filtering thresholds.”

```{r}
resApeT <- lfcShrink(dds, coef=2, type="apeglm", lfcThreshold=1)
plotMA(resApeT, ylim=c(-10,10), cex=.8)
abline(h=c(-1,1), col="dodgerblue", lwd=2)
```


#### P-value distribution

It is also important to observe the distribution of raw p-values. We expect to see a peak around low p-values and a uniform distribution at P-values above 0.1. Otherwise, adjustment for multiple testing does not work and the results are not meaningful.
```{r}
library(ggplot2)
ggplot(data = as.data.frame(DEresults), aes(x = pvalue)) + 
  geom_histogram(bins = 100)
```
#### PCA plot

A final diagnosis is to check the biological reproducibility of the sample replicates in a PCA plot or a heatmap. To plot the PCA results, we need to extract the normalized counts from the DESeqDataSet object. It is possible to color the points in the scatter plot by the variable of interest, which helps to see if the replicates cluster well

```{r}
library(DESeq2)
vsd <- vst(dds)
DESeq2::plotPCA(vsd, ntop = 100, intgroup = 'RADIATION.CLASS') + 
  ylim(-50, 50) + theme_bw()
```




References:  
1. https://compgenomr.github.io/book/gene-expression-analysis-using-high-throughput-sequencing-technologies.html